% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lm_knockoff.R
\name{lm_knockoff}
\alias{lm_knockoff}
\title{Perform one random experiment}
\usage{
lm_knockoff(
  X,
  y,
  T_stop = 1,
  num_dummies = ncol(X),
  method = "tknock",
  type = "lar",
  corr_max = 0.5,
  lambda_2_lars = NULL,
  early_stop = TRUE,
  lars_state,
  verbose = TRUE,
  intercept = FALSE,
  normalize = TRUE,
  cor.structure = FALSE,
  empirical = FALSE
)
}
\arguments{
\item{X}{Real valued predictor matrix.}

\item{y}{Response vector.}

\item{T_stop}{Number of included dummies after which the random experiments (i.e., forward selection processes) are stopped.}

\item{num_dummies}{Number of dummies}

\item{method}{'tknock' for T-Knock filter and 'tknock+GVS' for T-Knock+GVS filter.}

\item{type}{'lar' for 'LARS' and 'lasso' for Lasso.}

\item{corr_max}{Maximum allowed correlation between any two predictors from different clusters.}

\item{lambda_2_lars}{lambda_2-value for LARS-based Elastic Net.}

\item{early_stop}{If TRUE, then the forward selection process is stopped after T_stop dummies have been included. Otherwise the entire solution path is computed.}

\item{lars_state}{LARS object (i.e., object of the class tlarsCpp). Contains variables associated with previous stopping point (necessary to restart forward selection selection process exactly where it was previously terminated).}

\item{verbose}{If TRUE progress in computations is shown.}

\item{intercept}{If TRUE an intercept is included.}

\item{normalize}{If TRUE the predictors are standardized and the response is centered.}

\item{cor.structure}{TRUE/FALSE.}

\item{empirical}{TRUE/FALSE.}
}
\value{
LARS object (i.e., object of the class tlars_cpp).
}
\description{
Run one random experiment of the T-Knock filter, i.e., generates dummies, appends them to the predictor matrix, and runs the forward selection algorithm until it is terminated after T_stop dummies have been selected.
}
\examples{
set.seed(123)
eps = .Machine$double.eps
n = 75
p = 100
X = matrix(stats::rnorm(n * p), nrow = n, ncol = p)
beta = c(rep(3, times = 3), rep(0, times = 97))
y = X \%*\% beta + rnorm(n)
res = lm_knockoff(X, y, T_stop = 1, L_val = 5 * p)
support = abs(res$getLastBeta()[seq(p)]) > eps
support
}
